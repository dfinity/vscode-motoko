import { Motoko } from 'motoko/lib';
import * as baseLibrary from 'motoko/packages/latest/base.json';
import ImportResolver from './imports';
import AstResolver from './ast';

/**
 * A Motoko compiler context.
 */
export class Context {
    public readonly uri: string;
    public readonly motoko: Motoko;
    public readonly astResolver: AstResolver;
    public readonly importResolver: ImportResolver;

    public packages: [string, string][] | undefined;
    public error: string | undefined;

    constructor(uri: string, motoko: Motoko) {
        this.uri = uri;
        this.motoko = motoko;
        this.astResolver = new AstResolver(this);
        this.importResolver = new ImportResolver(this);
    }
}

const motokoPath = './motoko'; // Bundle generated by `esbuild`

// Compiler contexts (for workspaces with multiple Vessel directories)
const contexts: Context[] = [];

// Reuse `motoko` npm package instances to limit memory usage
const previousMotokoInstances = new Map<string, Motoko>();

/**
 * Create or reuse a `moc.js` compiler instance.
 */
function requestMotokoInstance(uri: string): Motoko {
    let motoko = previousMotokoInstances.get(uri)!;
    if (motoko) {
        motoko.clearPackages();
    } else {
        Object.keys(require.cache).forEach((key) => {
            if (
                key.endsWith('/out/motoko.js') ||
                key.endsWith('\\out\\motoko.js')
            ) {
                // console.warn('Deleting cache:', key);
                delete require.cache[key];
            }
        });
        motoko = require(motokoPath).default;
    }
    motoko.loadPackage(baseLibrary);
    return motoko;
}

let defaultContext: Context | undefined;
function requestDefaultContext() {
    if (!defaultContext) {
        defaultContext = addContext('');
        // console.warn('Created default context');
    }
    return defaultContext;
}
requestDefaultContext(); // Always add a default context (provisional)

/**
 * Reset all contexts (used to update Vessel configuration).
 */
export function resetContexts() {
    contexts.forEach(({ uri, motoko }) => {
        previousMotokoInstances.set(uri, motoko);
    });
    contexts.length = 0;
    if (defaultContext) {
        defaultContext = undefined;
        requestDefaultContext(); // Regenerate default context
    }
}

/**
 * Register a context for the given directory (specified as a URI).
 */
export function addContext(uri: string): Context {
    const existing = contexts.find((other) => uri === other.uri);
    if (existing) {
        console.warn('Duplicate contexts for URI:', uri);
        return existing;
    }
    const motoko = requestMotokoInstance(uri);
    const context = new Context(uri, motoko);
    // Insert by descending specificity (`uri.length`) and then ascending alphabetical order
    let index = 0;
    while (index < contexts.length) {
        const other = contexts[index];
        if (
            uri.length > other.uri.length ||
            (uri.length === other.uri.length &&
                uri.localeCompare(other.uri) < 0)
        ) {
            break;
        }
        index++;
    }
    contexts.splice(index, 0, context);
    return context;
}

/**
 * Return all currently active contexts.
 */
export function allContexts(): Context[] {
    return contexts;
}

/**
 * Find the most relevant context for the given URI.
 */
export function getContext(uri: string): Context {
    const context = contexts.find((context) => uri.startsWith(context.uri));
    if (context) {
        return context;
    }
    console.warn('Unknown context for URI:', uri);
    return requestDefaultContext();
}

/**
 * Check if a context is available for the given URI.
 */
export function hasContext(uri: string): boolean {
    return contexts.some((context) => uri.startsWith(context.uri));
}
