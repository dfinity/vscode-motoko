import { existsSync } from 'fs';
import { type Motoko } from 'motoko/lib';
import * as baseLibrary from 'motoko/packages/latest/base.json';
import { basename, dirname, isAbsolute, join, resolve } from 'path';
import AstResolver from './ast';
import ImportResolver from './imports';
import { extractMocVersion, getMocJs } from './utils';
import { settings } from './globals';
import { Result, ok, err } from 'neverthrow';

type MocJsInfo = {
    version?: string;
    path?: string;
};

type Version = string | undefined;

/**
 * A Motoko compiler context.
 */
export class Context {
    public readonly uri: string;
    public readonly mocJsInfo: MocJsInfo;
    public readonly motoko: Motoko;
    public readonly astResolver: AstResolver;
    public readonly importResolver: ImportResolver;

    public packages: [string, string][] | undefined;
    public error: string | undefined;

    constructor(uri: string, motoko: Motoko, mocJsInfo?: MocJsInfo) {
        this.uri = uri;
        this.mocJsInfo = mocJsInfo || {};
        this.motoko = motoko;
        this.astResolver = new AstResolver(this);
        this.importResolver = new ImportResolver(this);
    }
}

const motokoPath = './motoko'; // Bundle generated by `esbuild`

// Compiler contexts (for workspaces with multiple Vessel directories)
const contexts: Context[] = [];

// Reuse `motoko` npm package instances to limit memory usage
const motokoInstances = new Map<string, Motoko>();

function getMotokoInstanceKey(
    uri: string,
    version: Version,
    workspaceRoot?: string,
) {
    return `${uri}:${version || ''}:${settings?.mocJsPath || ''}:${
        workspaceRoot || ''
    }`;
}

/**
 * Create or reuse a `moc.js` compiler instance.
 */
async function requestMotokoInstance(
    uri: string,
    version: Version,
    workspaceRoot: string,
): Promise<[Motoko, MocJsInfo]> {
    let motoko = motokoInstances.get(
        getMotokoInstanceKey(uri, version, workspaceRoot),
    )!;
    let mocJsInfo: MocJsInfo = {};

    if (motoko) {
        motoko.clearPackages();
    } else {
        Object.keys(require.cache).forEach((key) => {
            if (
                key.endsWith('/out/motoko.js') ||
                key.endsWith('\\out\\motoko.js') ||
                key.includes('/out/compiler/') ||
                key.includes('\\out\\compiler\\')
            ) {
                delete require.cache[key];
            }
        });

        [motoko, mocJsInfo] = await createMotokoInstance(
            version,
            workspaceRoot,
        );

        configureMotokoCompiler(motoko);

        motokoInstances.set(
            getMotokoInstanceKey(uri, version, workspaceRoot),
            motoko,
        );
    }
    configureMotokoInstance(motoko);
    return [motoko, mocJsInfo];
}

function configureMotokoCompiler(motoko: Motoko) {
    motoko.compiler.setTypecheckerCombineSrcs?.(true);
    motoko.compiler.setBlobImportPlaceholders?.(true);
}

// Required for temporary deployment (originally Motoko Playground)
function configureMotokoInstance(motoko: Motoko) {
    motoko.setPublicMetadata([
        'candid:service',
        'candid:args',
        'motoko:stable-types',
    ]);
    motoko.loadPackage(baseLibrary);
}

async function createMotokoInstance(
    version: Version,
    workspaceRoot: string,
): Promise<[Motoko, MocJsInfo]> {
    const configuredMocJsPath = settings.mocJsPath;
    if (configuredMocJsPath) {
        console.log('Trying to use custom moc.js path:', configuredMocJsPath);
        const resolvedPath = isAbsolute(configuredMocJsPath)
            ? configuredMocJsPath
            : resolve(workspaceRoot, configuredMocJsPath);
        const filename = basename(resolvedPath);
        const mocVersion = extractMocVersion(filename);

        if (existsSync(resolvedPath)) {
            const res = getCompiler(resolvedPath);
            if (res.isOk()) {
                const [compiler, path] = res.value;
                return [
                    require('motoko/lib').default(compiler),
                    {
                        // assume that moc.js version in file name is correct, otherwise
                        // use provided version
                        version: mocVersion || version,
                        path,
                    },
                ];
            } else {
                // TODO: notify user via `connection.sendMessage()`
                console.error(
                    `Error loading custom moc.js from ${configuredMocJsPath}:`,
                    res.error.message,
                );
            }
        } else {
            // TODO: notify user via `connection.sendMessage()`
            console.warn(
                `Custom moc.js file not found at ${resolvedPath}, trying to download`,
            );
            if (mocVersion) {
                const res = await getMocJs(
                    mocVersion,
                    dirname(resolvedPath),
                ).andThen((path) => getCompiler(path));
                if (res.isOk()) {
                    const [compiler, path] = res.value;
                    return [
                        require('motoko/lib').default(compiler),
                        {
                            version: mocVersion,
                            path,
                        },
                    ];
                } else {
                    console.error(
                        `Error while downloading custom moc.js to ${configuredMocJsPath}:`,
                        res.error.message,
                    );
                }
            }
        }
    }

    if (version) {
        const mocJsDir = join(__dirname, 'compiler');
        const res = await getMocJs(version, mocJsDir).andThen((path) =>
            getCompiler(path),
        );
        if (res.isOk()) {
            console.log('Using workspace moc.js version:', version);
            const [compiler, path] = res.value;
            return [
                require('motoko/lib').default(compiler),
                {
                    version,
                    path,
                },
            ];
        } else {
            console.warn(
                "Can't load moc.js for version",
                version,
                ':',
                res.error.message,
            );
        }
    }

    console.log('Falling back to bundled motoko package');

    return [require(motokoPath).default, {}];

    function getCompiler(path: string): Result<[any, string], Error> {
        try {
            const compiler = require(path).Motoko;
            if (!compiler) {
                return err(
                    new Error('Invalid moc.js file: missing Motoko export'),
                );
            }
            return ok([compiler, path]);
        } catch (error: any) {
            return err(
                error instanceof Error ? error : new Error(String(error)),
            );
        }
    }
}

let defaultContext: Context | undefined;
function requestDefaultContext() {
    if (!defaultContext) {
        const motoko = require(motokoPath).default;
        configureMotokoCompiler(motoko);

        motokoInstances.set(getMotokoInstanceKey('', undefined), motoko);
        configureMotokoInstance(motoko);
        defaultContext = new Context('', motoko);
        insertContext(defaultContext);
    }
    return defaultContext;
}
requestDefaultContext(); // Always add a default context

/**
 * Reset all contexts (used to update Vessel configuration).
 */
export function resetContexts() {
    contexts.length = 0;
    if (defaultContext) {
        defaultContext = undefined;
        requestDefaultContext(); // Regenerate default context
    }
}

/**
 * Register a context for the given directory (specified as a URI).
 */
export async function addContext(
    uri: string,
    version?: Version,
    workspaceRoot?: string,
): Promise<Context> {
    const existing = contexts.find((other) => uri === other.uri);
    if (existing) {
        console.warn('Duplicate contexts for URI:', uri);
        return existing;
    }
    const [motoko, mocJsInfo] = await requestMotokoInstance(
        uri,
        version,
        workspaceRoot || '',
    );
    const context = new Context(uri, motoko, mocJsInfo);
    insertContext(context);
    return context;
}

/**
 * Inserts a context object into the global contexts array, maintaining order.
 * The order is determined first by URI length (shorter URIs come later),
 * then lexicographically by URI if lengths are equal.
 *
 * @param context - The context object to insert.
 */
function insertContext(context: Context) {
    let index = 0;
    const uri = context.uri;
    while (index < contexts.length) {
        const other = contexts[index];
        if (
            uri.length > other.uri.length ||
            (uri.length === other.uri.length &&
                uri.localeCompare(other.uri) < 0)
        ) {
            break;
        }
        index++;
    }
    contexts.splice(index, 0, context);
}

/**
 * Return all currently active contexts.
 */
export function allContexts(): Context[] {
    return contexts;
}

/**
 * Find the most relevant context for the given URI.
 */
export function getContext(uri: string): Context {
    const context = contexts.find((context) => uri.startsWith(context.uri));
    if (context) {
        return context;
    }
    console.warn('Unknown context for URI:', uri);
    return requestDefaultContext();
}

/**
 * Check if a context is available for the given URI.
 */
export function hasContext(uri: string): boolean {
    return contexts.some((context) => uri.startsWith(context.uri));
}
