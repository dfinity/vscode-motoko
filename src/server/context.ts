import { type Motoko } from 'motoko/lib';
import * as basePackage from 'motoko/packages/latest/base.json';
import * as corePackage from 'motoko/packages/latest/core.json';
import AstResolver from './ast';
import ImportResolver from './imports';

type Version = string | undefined; // `undefined` refers to latest version

/**
 * A Motoko compiler context.
 */
export class Context {
    public readonly uri: string;
    public readonly version: Version;
    public readonly motoko: Motoko;
    public readonly astResolver: AstResolver;
    public readonly importResolver: ImportResolver;

    public packages: [string, string][] | undefined;
    public error: string | undefined;

    constructor(uri: string, version: Version, motoko: Motoko) {
        this.version = version;
        this.uri = uri;
        this.motoko = motoko;
        this.astResolver = new AstResolver(this);
        this.importResolver = new ImportResolver(this);
    }
}

const motokoPath = './motoko'; // Bundle generated by `esbuild`

// Compiler contexts (for workspaces with multiple Vessel directories)
const contexts: Context[] = [];

// Reuse `motoko` npm package instances to limit memory usage
const previousMotokoInstances = new Map<string, Motoko>();

function getMotokoInstanceKey(uri: string, version: Version) {
    return `${uri}:${version}`;
}

/**
 * Create or reuse a `moc.js` compiler instance.
 */
function requestMotokoInstance(uri: string, version: Version): Motoko {
    let motoko = previousMotokoInstances.get(
        getMotokoInstanceKey(uri, version),
    )!;
    if (motoko) {
        motoko.clearPackages();
    } else {
        Object.keys(require.cache).forEach((key) => {
            if (
                key.endsWith('/out/motoko.js') ||
                key.endsWith('\\out\\motoko.js') ||
                key.includes('/out/compiler/') ||
                key.includes('\\out\\compiler\\')
            ) {
                delete require.cache[key];
            }
        });
        motoko = require(motokoPath).default;
        motoko.setTypecheckerCombineSrcs(true);
    }
    // Required for temporary deployment (originally Motoko Playground)
    motoko.setPublicMetadata([
        'candid:service',
        'candid:args',
        'motoko:stable-types',
    ]);
    motoko.loadPackage(basePackage);
    motoko.loadPackage(corePackage);
    return motoko;
}

let defaultContext: Context | undefined;
function requestDefaultContext() {
    if (!defaultContext) {
        defaultContext = addContext('');
    }
    return defaultContext;
}
requestDefaultContext(); // Always add a default context

/**
 * Reset all contexts (used to update Vessel configuration).
 */
export function resetContexts() {
    contexts.forEach(({ uri, version, motoko }) => {
        previousMotokoInstances.set(getMotokoInstanceKey(uri, version), motoko);
    });
    contexts.length = 0;
    if (defaultContext) {
        defaultContext = undefined;
        requestDefaultContext(); // Regenerate default context
    }
}

/**
 * Register a context for the given directory (specified as a URI).
 */
export function addContext(uri: string, version?: Version): Context {
    const existing = contexts.find((other) => uri === other.uri);
    if (existing) {
        console.warn('Duplicate contexts for URI:', uri);
        return existing;
    }
    const motoko = requestMotokoInstance(uri, version);
    const context = new Context(uri, version, motoko);
    // Insert by descending specificity (`uri.length`) and then ascending alphabetical order
    let index = 0;
    while (index < contexts.length) {
        const other = contexts[index];
        if (
            uri.length > other.uri.length ||
            (uri.length === other.uri.length &&
                uri.localeCompare(other.uri) < 0)
        ) {
            break;
        }
        index++;
    }
    contexts.splice(index, 0, context);
    return context;
}

/**
 * Return all currently active contexts.
 */
export function allContexts(): Context[] {
    return contexts;
}

/**
 * Find the most relevant context for the given URI.
 */
export function getContext(uri: string): Context {
    const context = contexts.find((context) => uri.startsWith(context.uri));
    if (context) {
        return context;
    }
    console.warn('Unknown context for URI:', uri);
    return requestDefaultContext();
}

/**
 * Check if a context is available for the given URI.
 */
export function hasContext(uri: string): boolean {
    return contexts.some((context) => uri.startsWith(context.uri));
}
