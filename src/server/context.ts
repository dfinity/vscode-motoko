// import defaultMotoko from 'motoko';
import { Motoko } from 'motoko/lib';
import ImportResolver from './imports';
import AstResolver from './ast';

export interface Context {
    uri: string;
    motoko: Motoko;
    astResolver: AstResolver;
    importResolver: ImportResolver;
    error: string | undefined;
}

const motokoPath = './motoko'; // Bundle generated by `esbuild`

const contexts: Context[] = [];

// Reuse `motoko` npm package instances to limit memory usage
const previousMotokoInstances = new Map<string, Motoko>();

function requestMotokoInstance(uri: string): Motoko {
    let motoko = previousMotokoInstances.get(uri);
    if (motoko) {
        motoko.clearPackages();
        return motoko;
    } else {
        Object.keys(require.cache).forEach((key) => {
            if (
                key.endsWith('/out/motoko.js') ||
                key.endsWith('\\out\\motoko.js')
            ) {
                // console.warn('Deleting cache:', key);
                delete require.cache[key];
            }
        });
        return require(motokoPath).default;
    }
}

let defaultContext: Context | undefined;
function requestDefaultContext() {
    if (!defaultContext) {
        defaultContext = addContext('');
        console.warn('Created default context');
    }
    return defaultContext;
}

function createContext(uri: string, motoko: Motoko): Context {
    return {
        uri,
        motoko,
        astResolver: new AstResolver(),
        importResolver: new ImportResolver(),
        error: undefined,
    };
}

export function resetContexts() {
    contexts.forEach(({ uri, motoko }) => {
        // reusableMotokoInstances.push(context.motoko);
        previousMotokoInstances.set(uri, motoko);
    });
    contexts.length = 0;
    if (defaultContext) {
        defaultContext = undefined;
    }
}

export function addContext(uri: string): Context {
    const existing = contexts.find((other) => uri === other.uri);
    if (existing) {
        console.warn('Duplicate contexts for URI:', uri);
        return existing;
    }
    const motoko = requestMotokoInstance(uri);
    const context = createContext(uri, motoko);
    // Insert by descending specificity (`uri.length`) and then ascending alphabetical order
    let index = 0;
    while (index < contexts.length) {
        const other = contexts[index];
        if (
            uri.length > other.uri.length ||
            (uri.length === other.uri.length &&
                uri.localeCompare(other.uri) < 0)
        ) {
            break;
        }
        index++;
    }
    contexts.splice(index, 0, context);
    return context;
}

export function allContexts(): Context[] {
    return contexts;
}

export function getContext(uri: string): Context {
    const context = contexts.find((context) => uri.startsWith(context.uri));
    if (context) {
        return context;
    }
    console.warn('Unknown context for URI:', uri);
    return requestDefaultContext();
}

export function hasContext(uri: string): boolean {
    return contexts.some((context) => uri.startsWith(context.uri));
}
