import { existsSync } from 'fs';
import { type Motoko } from 'motoko/lib';
import * as baseLibrary from 'motoko/packages/latest/base.json';
import { isAbsolute, join, resolve } from 'path';
import AstResolver from './ast';
import ImportResolver from './imports';
import { resolveFilePath } from './utils';

type Version = {
    version?: string;
    mocJsPath?: string;
};

/**
 * A Motoko compiler context.
 */
export class Context {
    public readonly uri: string;
    public readonly version: Version;
    public readonly motoko: Motoko;
    public readonly astResolver: AstResolver;
    public readonly importResolver: ImportResolver;
    public readonly workspaceRoot: string;

    public packages: [string, string][] | undefined;
    public error: string | undefined;

    constructor(uri: string, version: Version, workspaceRoot?: string) {
        this.uri = uri;
        this.version = version;
        this.workspaceRoot = workspaceRoot || resolveFilePath(uri);
        this.motoko = requestMotokoInstance(uri, version, this.workspaceRoot);
        this.astResolver = new AstResolver(this);
        this.importResolver = new ImportResolver(this);
    }
}

const motokoPath = './motoko'; // Bundle generated by `esbuild`

// Compiler contexts (for workspaces with multiple Vessel directories)
const contexts: Context[] = [];

// Reuse `motoko` npm package instances to limit memory usage
const motokoInstances = new Map<string, Motoko>();

function getMotokoInstanceKey(
    uri: string,
    version: Version,
    workspaceRoot?: string,
) {
    return `${uri}:${version.version || ''}:${version.mocJsPath || ''}:${
        workspaceRoot || ''
    }`;
}

/**
 * Create or reuse a `moc.js` compiler instance.
 */
function requestMotokoInstance(
    uri: string,
    version: Version,
    workspaceRoot: string,
): Motoko {
    let motoko = motokoInstances.get(
        getMotokoInstanceKey(uri, version, workspaceRoot),
    )!;
    if (motoko) {
        motoko.clearPackages();
    } else {
        Object.keys(require.cache).forEach((key) => {
            if (
                key.endsWith('/out/motoko.js') ||
                key.endsWith('\\out\\motoko.js') ||
                key.includes('/out/compiler/') ||
                key.includes('\\out\\compiler\\')
            ) {
                delete require.cache[key];
            }
        });

        motoko = createMotokoInstance(version, workspaceRoot);

        motoko.compiler.setTypecheckerCombineSrcs?.(true);
        motoko.compiler.setBlobImportPlaceholders?.(true);

        motokoInstances.set(
            getMotokoInstanceKey(uri, version, workspaceRoot),
            motoko,
        );
    }
    // Required for temporary deployment (originally Motoko Playground)
    motoko.setPublicMetadata([
        'candid:service',
        'candid:args',
        'motoko:stable-types',
    ]);
    motoko.loadPackage(baseLibrary);
    return motoko;
}

function createMotokoInstance(
    { version, mocJsPath }: Version,
    workspaceRoot: string,
): Motoko {
    if (mocJsPath) {
        console.log('Using custom moc.js path:', mocJsPath);
        try {
            const resolvedPath = isAbsolute(mocJsPath)
                ? mocJsPath
                : resolve(workspaceRoot, mocJsPath);

            if (existsSync(resolvedPath)) {
                const compiler = require(resolvedPath).Motoko;
                if (!compiler) {
                    throw new Error(
                        'Invalid moc.js file: missing Motoko export',
                    );
                }
                return require('motoko/lib').default(compiler);
            } else {
                // TODO: notify user via `connection.sendMessage()`
                console.error(
                    `Custom moc.js file not found at ${resolvedPath}, falling back to default`,
                );
            }
        } catch (error: any) {
            // TODO: notify user via `connection.sendMessage()`
            console.error(
                `Error loading custom moc.js from ${mocJsPath}:`,
                error,
            );
        }
    }

    if (version === '0.10.4') {
        const compiler = require(join(
            __dirname,
            '/compiler/moc-' + version,
        )).Motoko;
        return require('motoko/lib').default(compiler);
    }

    return require(motokoPath).default;
}

let defaultContext: Context | undefined;
function requestDefaultContext() {
    if (!defaultContext) {
        defaultContext = addContext('', {});
    }
    return defaultContext;
}
requestDefaultContext(); // Always add a default context

/**
 * Reset all contexts (used to update Vessel configuration).
 */
export function resetContexts() {
    contexts.length = 0;
    if (defaultContext) {
        defaultContext = undefined;
        requestDefaultContext(); // Regenerate default context
    }
}

/**
 * Register a context for the given directory (specified as a URI).
 */
export function addContext(
    uri: string,
    version: Version,
    workspaceRoot?: string,
): Context {
    const existing = contexts.find((other) => uri === other.uri);
    if (existing) {
        console.warn('Duplicate contexts for URI:', uri);
        return existing;
    }
    const context = new Context(uri, version, workspaceRoot);
    // Insert by descending specificity (`uri.length`) and then ascending alphabetical order
    let index = 0;
    while (index < contexts.length) {
        const other = contexts[index];
        if (
            uri.length > other.uri.length ||
            (uri.length === other.uri.length &&
                uri.localeCompare(other.uri) < 0)
        ) {
            break;
        }
        index++;
    }
    contexts.splice(index, 0, context);
    return context;
}

/**
 * Return all currently active contexts.
 */
export function allContexts(): Context[] {
    return contexts;
}

/**
 * Find the most relevant context for the given URI.
 */
export function getContext(uri: string): Context {
    const context = contexts.find((context) => uri.startsWith(context.uri));
    if (context) {
        return context;
    }
    console.warn('Unknown context for URI:', uri);
    return requestDefaultContext();
}

/**
 * Check if a context is available for the given URI.
 */
export function hasContext(uri: string): boolean {
    return contexts.some((context) => uri.startsWith(context.uri));
}
